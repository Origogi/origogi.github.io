---
published: true
title: "[Coroutine] 코루틴 디스패쳐"
excerpt : " "
layout: single
author_profile: true
read_time: false
toc: true
toc_label: "My Table of Contents"
toc_icon: "cog"
toc_sticky: true
categories :
 - Kotlin
 - Coroutine


comments: true
header:
  # overlay_image: https://cf.festa.io/img/2019-9-27/a6c0b457-c336-42ba-b06e-462de90ada91.jpg
  # overlay_filter: 0.5
  # teaser: https://cf.festa.io/img/2019-9-27/a6c0b457-c336-42ba-b06e-462de90ada91.jpg
sitemap :
  changefreq : daily
  priority : 1.0
---

## 디스패치/디스패쳐

디스패치란 다중 프로그래밍 시스템에서 다음에 처리될 작업을 선택하여 실행시키는 것. 즉, 대기열에서 기다리고 있는 프로세스/스레드를 선택하여 중앙 처리 장치의 사용 권한을 부여하는 작업을 뜻합니다. 따라서 디스패쳐란 위 디스패치의 역할을 수행하는 주체라고 보시면 됩니다. 디스패치/디스패쳐라는 용어는 컴퓨터에 자주 쓰이기 때문에 꼭 기억을 합시다.

## 코루틴 디스패쳐

코틀린에서는 스레드와 스레드 풀을 쉽게 만들 수 있지만 직접 엑세스하거나 제어하지 않는다는 점을 알아야 한다. 코루틴 디스패쳐의 역할은 기본적으로 가용성, 부하, 설정을 기반으로 스레드 간에 코루틴을 분산하는 `오케스트레이터`입니다.

## 코루틴을 시작할 때 특정 디스패쳐 사용하기

아래 코드는 기본 디스패쳐를 사용하고 있다.

~~~kotlin
fun main() {
    runBlocking {
        val task = launch {
            printCurrentThread()
        }
        task.join()
    }
}
~~~

printCurrentThread() 는 현재 스레드의 이름을 출력한다.

~~~kotlin
fun printCurrentThread () {
    println("Running in the thread [${Thread.currentThread().name}]")
}
~~~

위 코드를 실행하면 아래의 결과를 출력한다.

~~~kotlin
> Task :TestKt.main()
Running in the thread [main @coroutine#2]
~~~

디폴트 디스패쳐 외에 직접 디스패처를 생성하여 사용할 수 있다. 아래 코드를 살펴보자

~~~kotlin
fun main() {
    runBlocking {

        val dispatcher = newSingleThreadContext(name = "ServiceCall")
        val task = GlobalScope.launch(dispatcher) {
            printCurrentThread()
        }
        task.join()
    }
}
~~~

위 코드를 실행하면 아래의 결과를 출력하는 것을 확인할 수 있다.

~~~kotlin
> Task :TestKt.main()
Running in the thread [ServiceCall @coroutine#2]
~~~

### Reference

코틀린 동시성 프로그래밍(에이콘)
  