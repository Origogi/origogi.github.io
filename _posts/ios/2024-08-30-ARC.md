---
published: false
title: "[iOS][Swift] ARC (Automatic Reference Counting) 정리"	
excerpt : " "	
layout: single	
classes: wide
author_profile: true
read_time: false
toc: true
toc_label: "My Table of Contents"
toc_icon: "cog"
toc_sticky: true
categories :	
 - iOS	
tags: 	
  - iOS
  - Swift

comments: true	
header:
  overlay_image: https://github.com/user-attachments/assets/9b9bbd57-859f-473b-81b2-178a9d7d69e6
  overlay_filter: 0.4
  teaser: https://github.com/user-attachments/assets/9b9bbd57-859f-473b-81b2-178a9d7d69e6
sitemap :	
  changefreq : daily	
  priority : 1.0	
---

![banner](https://github.com/user-attachments/assets/9b9bbd57-859f-473b-81b2-178a9d7d69e6)

## 서론

해당 포스트는 ARC에 대해서 정리한 포스트입니다.

## ARC (Automatic Reference Counting)

ARC 는 Swift 에서 사용되는 메모리 관리 방식이다. 기본적인 원리는 객체를 소유또는 참조하는 모든 객체의 수를 추적하여 객체가 더 이상 필요하지 않을 때 메모리에서 해제하는 방식이다.
예를 들어 객체 A를 어떤 변수에 할당하면 A의 참조 카운트가 1 증가하고, 또 객체 A를 다른 변수에 할당하면 참조 카운트가 1 증가한다. 만약 변수가 nil 이 되거나 다른 객체를 참조하게 되면 참조 카운트가 1 감소한다. 참조 카운트가 0이 되면 메모리에서 해제된다.

```swift
class Person {

  deinit {
    print("Person 객체가 메모리에서 해제됨")
  }
}

var a: Person? = Person() // Person이라는 객체가 생성됨과 동시에 a 변수에 할당되어 Person 객체의 참조 카운트가 1 증가
var b: Person? = a // Person 객체의 참조 카운트가 1 증가

a = nil // Person 객체의 참조 카운트가 1 감소
b = nil // Person 객체의 참조 카운트가 1 감소, Person 객체가 메모리에서 해제되면서 deinit 메소드가 호출됨
```

## Strong Reference

일반적은 객체 참조 방식이다. 객체를 어떤 변수가 참조하게 되면 참조 카운트가 1 증가하고, 변수가 nil 이 되거나 다른 객체를 참조하게 되면 참조 카운트가 1 감소한다.
위 예제에서 사용한 방식이 Strong Reference 이다.

## Weak Reference

객체를 참조하지만 객체의 참조 카운트를 증가시키지 않는 방법이 존재한다. 이를 Weak Reference 라고 한다. 
변수 키워드 앞에 `weak` 또는 `unowned` 키워드를 사용하여 객체를 참조할 수 있다.

어떻게 보면 참조 카운트를 임의로 증가시키지 않아서 무언가 위험하고 버그가 발생할 것 같고 사용하면 안되는 것처럼 보일수 있다.
하지만 iOS Framework 에서는 많은 곳에서 사용되고 있다. iOS Framework 에서는 Delegate 패턴을 많이 사용하는데 이때 Delegate 객체를 참조할 때 Weak Reference 를 적극적으로 사용한다.

### Delegate 패턴

Delegate 패턴은 객체의 행동을 다른 객체에게 위임하는 패턴이다. 객체 A가 객체 B에게 자신의 행동을 위임하고, 객체 B는 객체 A의 행동을 대신 수행한다.
이때 객체 A는 객체 B를 생성하면서 B를 참조하고 있고 객체 B의 생성자에 객체 A의 참조를 전달하는 방식이다.

여기서 객체 참조에 대해서 특별한 처리를 하지 않으면 객체 A와 객체 B는 서로 참조하고 있기 때문에 참조 카운트가 1 증가하고 두 객체는 메모리에서 해제되지 않는다. 이러한 문제를 해결하기 위해 Delegate 객체를 참조할 때 Weak Reference 를 사용한다.

```swift

## Reference

[ARC 공식문서](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/)