---
published: false
title: "[iOS][Swift] ARC (Automatic Reference Counting) 정리"	
excerpt : " "	
layout: single	
classes: wide
author_profile: true
read_time: false
toc: true
toc_label: "My Table of Contents"
toc_icon: "cog"
toc_sticky: true
categories :	
 - iOS	
tags: 	
  - iOS
  - Swift

comments: true	
header:
  overlay_image: https://github.com/user-attachments/assets/9b9bbd57-859f-473b-81b2-178a9d7d69e6
  overlay_filter: 0.4
  teaser: https://github.com/user-attachments/assets/9b9bbd57-859f-473b-81b2-178a9d7d69e6
sitemap :	
  changefreq : daily	
  priority : 1.0	
---

![banner](https://github.com/user-attachments/assets/9b9bbd57-859f-473b-81b2-178a9d7d69e6)

## 서론

해당 포스트는 ARC에 대해서 정리한 포스트입니다.

## ARC (Automatic Reference Counting)

ARC 는 Swift 에서 사용되는 메모리 관리 방식이다. 기본적인 원리는 객체를 소유또는 참조하는 모든 객체의 수를 추적하여 객체가 더 이상 필요하지 않을 때 메모리에서 해제하는 방식이다.
예를 들어 객체 A를 어떤 변수에 할당하면 A의 참조 카운트가 1 증가하고, 또 객체 A를 다른 변수에 할당하면 참조 카운트가 1 증가한다. 만약 변수가 nil 이 되거나 다른 객체를 참조하게 되면 참조 카운트가 1 감소한다. 참조 카운트가 0이 되면 메모리에서 해제된다.

```swift
class Person {

  deinit {
    print("Person 객체가 메모리에서 해제됨")
  }
}

var a: Person? = Person() // Person이라는 객체가 생성됨과 동시에 a 변수에 할당되어 Person 객체의 참조 카운트가 1 증가
var b: Person? = a // Person 객체의 참조 카운트가 1 증가

a = nil // Person 객체의 참조 카운트가 1 감소
b = nil // Person 객체의 참조 카운트가 1 감소, Person 객체가 메모리에서 해제되면서 deinit 메소드가 호출됨
```

## Strong Reference

일반적은 객체 참조 방식이다. 객체를 어떤 변수가 참조하게 되면 참조 카운트가 1 증가하고, 변수가 nil 이 되거나 다른 객체를 참조하게 되면 참조 카운트가 1 감소한다.
위 예제에서 사용한 방식이 Strong Reference 이다.

## Weak Reference

객체를 참조하지만 객체의 참조 카운트를 증가시키지 않는 방법이 존재한다. 이를 Weak Reference 라고 한다. 
변수 키워드 앞에 `weak` 또는 `unowned` 키워드를 사용하여 객체를 참조할 수 있다.

어떻게 보면 참조 카운트를 임의로 증가시키지 않아서 무언가 위험하고 버그가 발생할 것 같고 사용하면 안되는 것처럼 보일수 있다.
하지만 iOS Framework 에서는 많은 곳에서 사용되고 있다. iOS Framework 에서는 `Delegate 패턴` 또는 `클로져` 을 많이 사용하는데 이때 Delegate 객체를 참조할 때 Weak Reference 를 적극적으로 사용한다.

### Delegate 패턴

Delegate 패턴은 객체의 행동을 다른 객체에게 위임하는 패턴이다. 객체 A가 객체 B에게 자신의 행동을 위임하고, 객체 B는 객체 A의 행동을 대신 수행한다.
이때 객체 A는 객체 B를 생성하면서 B를 참조하고 있고 객체 B의 생성자에 객체 A의 참조를 전달하는 방식이다.

여기서 객체 참조에 대해서 특별한 처리를 하지 않으면 객체 A와 객체 B는 서로 참조하고 있기 때문에 참조 카운트가 1 증가하고 두 객체는 메모리에서 해제되지 않는다. 이러한 문제를 해결하기 위해 Delegate 객체를 참조할 때 Weak Reference 를 사용한다.

## Sample Code (Strong Reference)

```swift
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}


class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}

var john: Person?
var unit4A: Apartment?

john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
```

위 코드는 Person과 Apartment 객체가 있고 Person john은 Apartment의 unit4A를 참조하고 있고, Apartment unit4A는 Person john을 참조하고 있다. 이때 객체 Person과 Apartment는 서로 참조하고 있고 또 변수에서 각각 참조하고 있기 때문에 각각 참조 카운트는 2이다.

![](https://docs.swift.org/swift-book/images/org.swift.tspl/referenceCycle02@2x.png)

이 때 john과 unit4A의 변수에 nil 를 할당하면 어떻게 될까? 

```swift
john = nil
unit4A = nil
```

단순히 생각하면 객체를 외부에서 직접 참조하는 변수가 없기 때문에 메모리에서 해제가 될 것 같고 실제로 해제가 되어야 한다. 만약 여기서 해제가 되지 않는다면 해당 객체는 메모리에서 살아있지만 실제로 접근할 수 없는 상태 즉 메모리 누수가 발생한다.

위 코드를 실행해보면 안타깝게도 메모리에서 해제되지 않는다. 이유는 서로 참조하고 있기 때문에 참조 카운트가 1이 남아있기 때문이다.

![](https://docs.swift.org/swift-book/images/org.swift.tspl/referenceCycle03@2x.png)

위 그림과 같이 Person 객체와 Apartment는 살아있지만 프로그램에서 접근할수 없는 상태가 된다. 즉 개발자 또는 프로그램이 객체를 컨트롤 할 수 없고 메모리에서 자리만 차지하고 있는 상태, 즉 메모리 누수가 발생한 것이다.

```swift

## Reference

[ARC 공식문서](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/)